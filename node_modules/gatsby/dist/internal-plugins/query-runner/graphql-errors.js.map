{"version":3,"sources":["../../../src/internal-plugins/query-runner/graphql-errors.js"],"names":["multipleRootQueriesError","graphqlValidationError","graphqlError","handlers","node","name","kind","value","loc","formatFilePath","filePath","format","bold","blue","formatError","message","codeFrame","stripIndent","extractError","error","docRegex","matches","docName","exec","toString","index","lastIndex","findLocation","extractedMessage","def","location","enter","regex","handler","match","slice","getCodeFrame","query","lineNumber","column","linesAbove","linesBelow","getCodeFrameFromRelayError","start","source","body","line","otherDef","otherName","unifiedName","camelCase","upperFirst","yellow","green","errors","doc","length","locations","namePathMap","nameDefMap","get","reportedMessage"],"mappings":"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","file":"graphql-errors.js","sourcesContent":["// @flow\n\nimport { print, visit, GraphQLError, getLocation } from \"graphql\"\nimport babelCodeFrame from \"babel-code-frame\"\nimport _ from \"lodash\"\nimport report from \"gatsby-cli/lib/reporter\"\n\ntype RelayGraphQLError = Error & { validationErrors?: Object }\n\n// These handle specific errors throw by RelayParser. If an error matches\n// you get a pointer to the location in the query that is broken, otherwise\n// we show the error and the query.\nconst handlers = [\n  [\n    /Unknown field `(.+)` on type `(.+)`/i,\n    ([name], node) => {\n      if (node.kind === `Field` && node.name.value === name) {\n        return node.name.loc\n      }\n      return null\n    },\n  ],\n  [\n    /Unknown argument `(.+)`/i,\n    ([name], node) => {\n      if (node.kind === `Argument` && node.name.value === name) {\n        return node.name.loc\n      }\n      return null\n    },\n  ],\n  [\n    /Unknown directive `@(.+)`/i,\n    ([name], node) => {\n      if (node.kind === `Directive` && node.name.value === name) {\n        return node.name.loc\n      }\n      return null\n    },\n  ],\n]\n\nfunction formatFilePath(filePath: string) {\n  return `${report.format.bold(`file:`)} ${report.format.blue(filePath)}`\n}\n\nfunction formatError(message: string, filePath: string, codeFrame: string) {\n  return (\n    report.stripIndent`\n    ${message}\n\n      ${formatFilePath(filePath)}\n  ` + `\\n\\n${codeFrame}\\n`\n  )\n}\n\nfunction extractError(error: Error): { message: string, docName: string } {\n  const docRegex = /Invariant Violation: (RelayParser|GraphQLParser): (.*). Source: document `(.*)` file:/g\n  let matches\n  let message = ``,\n    docName = ``\n  while ((matches = docRegex.exec(error.toString())) !== null) {\n    // This is necessary to avoid infinite loops with zero-width matches\n    if (matches.index === docRegex.lastIndex) docRegex.lastIndex++\n    ;[, , message, docName] = matches\n  }\n\n  if (!message) {\n    message = error.toString()\n  }\n\n  return { message, docName }\n}\n\nfunction findLocation(extractedMessage, def) {\n  let location = null\n  visit(def, {\n    enter(node) {\n      if (location) return\n      for (let [regex, handler] of handlers) {\n        let match = extractedMessage.match(regex)\n        if (!match) continue\n        if ((location = handler(match.slice(1), node))) break\n      }\n    },\n  })\n  return location\n}\n\nfunction getCodeFrame(query: string, lineNumber?: number, column?: number) {\n  return babelCodeFrame(query, lineNumber, column, {\n    linesAbove: 10,\n    linesBelow: 10,\n  })\n}\n\nfunction getCodeFrameFromRelayError(\n  def: any,\n  extractedMessage: string,\n  error: Error\n) {\n  let { start, source } = findLocation(extractedMessage, def) || {}\n  let query = source ? source.body : print(def)\n\n  // we can't reliably get a location without the location source, since\n  // the printed query may differ from the original.\n  let { line, column } = (source && getLocation(source, start)) || {}\n  return getCodeFrame(query, line, column)\n}\n\nexport function multipleRootQueriesError(\n  filePath: string,\n  def: any,\n  otherDef: any\n) {\n  let name = def.name.value\n  let otherName = otherDef.name.value\n  let unifiedName = `${_.camelCase(name)}And${_.upperFirst(\n    _.camelCase(otherName)\n  )}`\n\n  return formatError(\n    `Multiple \"root\" queries found in file: \"${name}\" and \"${otherName}\". ` +\n      `Only the first (\"${otherName}\") will be registered.`,\n    filePath,\n    `  ${report.format.yellow(`Instead of:`)} \\n\\n` +\n      babelCodeFrame(report.stripIndent`\n      query ${otherName} {\n        bar {\n          #...\n        }\n      }\n\n      query ${name} {\n        foo {\n          #...\n        }\n      }\n    `) +\n      `\\n\\n  ${report.format.green(`Do:`)} \\n\\n` +\n      babelCodeFrame(report.stripIndent`\n      query ${unifiedName} {\n        bar {\n          #...\n        }\n        foo {\n          #...\n        }\n      }\n    `)\n  )\n}\n\nexport function graphqlValidationError(\n  errors: Array<GraphQLError>,\n  filePath: string,\n  doc: any\n): string {\n  if (!errors || !errors.length) return ``\n  let error = errors[0]\n  let { source, locations: [{ line, column }] = [{}] } = error\n  let query = source ? source.body : print(doc)\n\n  return formatError(error.message, filePath, getCodeFrame(query, line, column))\n}\n\nexport function graphqlError(\n  namePathMap: Map<string, string>,\n  nameDefMap: Map<string, any>,\n  error: Error | RelayGraphQLError\n) {\n  let { message, docName } = extractError(error)\n  let filePath = namePathMap.get(docName)\n\n  if (filePath && docName) {\n    return formatError(\n      message,\n      filePath,\n      getCodeFrameFromRelayError(nameDefMap.get(docName), message, error)\n    )\n  }\n\n  let reportedMessage = `There was an error while compiling your site's GraphQL queries.\n  ${message || error.message}\n    `\n\n  if (error.message.match(/must be an instance of/)) {\n    reportedMessage +=\n      `This usually means that more than one instance of 'graphql' is installed ` +\n      `in your node_modules. Remove all but the top level one or run \\`npm dedupe\\` to fix it.`\n  }\n\n  if (error.message.match(/Duplicate document/)) {\n    reportedMessage += `${error.message.slice(21)}\\n`\n  }\n\n  return reportedMessage\n}\n"]}